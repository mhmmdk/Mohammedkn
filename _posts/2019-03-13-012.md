---
description: What is the value of the first triangle number to have over five hundred divisors?
title: Highly divisible triangular number
comments: true
num: 12
permalink: pro/highly-divisible-triangular-number
---

<div class='problem'>
<h3> Problem 12</h3>
<p>The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:<br><br>1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...<br><br>Let us list the factors of the first seven triangle numbers:
<pre>
     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28
</pre><br>We can see that 28 is the first triangle number to have over five divisors.<br><br>What is the value of the first triangle number to have over five hundred divisors?</p>
</div>

### Solution 1: Rough answer

```python

'''
#This method num_divisors(Num, start_divisor) only checks half of divisors
#and with out counting 1 and itself if start_divisor is > 1
#The number of full divisors is 2*ret of num_divisors
'''
def num_divisors(n, divisor):
    sqrtN = n**0.5    
    i = divisor
    c = 0               
    while i < sqrtN:
        if not n%i:
            divisor = i
            c += 1
            break 
        i += 1
    if i < sqrtN:
        divisor += 1
        c += num_divisors(n, divisor)
    return c


" Brute forcing which takes only 9.84299993515 sec"
i = 1
answer = 0
while True:
    n = (i**2 + i)//2           
    num = num_divisors(n, 1)

    if 2*num > 500:
        answer = n
        break
    i += 1
    
print(answer)
```
This run:~ 6.115420579910278 in good time.
The output: 76576500

### Solution 2:  
Why would we check for multiples of 2: 4,6,8,10,... while we know the number is divisible by
2 in our function <code>num_divisors(n, divisor)</code>? Why only for 2? For 3, 5 
and other primes too.  

For example let find num_divisors of 100:-  
There are  
- 100/2 = 50 multiples of 2(counting 100). 
- 100//3 = 33 multiples of 3(counting twice multiples of 6).  
- 100//5 = 20 multiples of 5(counting twice for multiples of 10 & 15).  

Removing redundunt counting.  
100//6 = 16  
100//10 = 10  
100//15 = 6  

So,  
There are 50 + 33 + 20 - 16 - 10 - 6 = 71 divisors and only we got 100 - 71 = 29 numbers to check.
This would significantly reduce our iterations in function <code>num_divisors(n, divisor)</code>.   

```python

'''

'''
def num_divisors(n):
    sqrtN = n**0.5    
    



" Brute forcing which takes only 9.84299993515 sec"
i = 1
answer = 0
while True:
    n = (i**2 + i)//2           
    num = num_divisors(n, 1)

    if 2*num > 500:
        answer = n
        break
    i += 1
    
print(answer)   
```







